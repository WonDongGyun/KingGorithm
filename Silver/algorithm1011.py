# 원동균 / 27조 / 1011 / Fly me to the Alpha Centauri
# (이 문제를 못 알아먹겠다면 그건 정상입니다.)
# (규칙을 전부 주석에 담기에는 무리가 있으니, 이 문제는 직접 노트에 하나씩 써보는것을 추천드립니다.)
# 이 문제는 숨겨져 있는 규칙이 많습니다.
# 1. 거리가 1, 4, 9, 16 ... 등 1ⁿ, 2², 3ⁿ, 4ⁿ ... 으로 떨어지는 경우에 새로운 숫자가 하나씩 추가 됩니다.
# 2. 만약 2²인 경우 (2-2 +1) ~ (2+2)의 범위에 속하는 거리 값들은 소수 첫째자리에서 반올림하면 딱 2로 떨어집니다. 규칙 1에 속하는 경우 전부 규칙 2를 적용할 수 있습니다.
# 3. 반드시 첫번째 값의 이동은 1만큼만 할 수 있습니다. 이전에 수행한 거리만큼 이동하기에 첫번째 값일 경우 이전에 수행한 거리는 0입니다.
# 4. 목적지에 도착하기 전에는 반드시 이전 단계에서 1만큼의 광년을 반드시 이동해야 합니다. 만약 5 ~ 목적지 8로 가고 싶다고 한번에 3을 뛰어 넘으면 안된다는 거죠
# 5. 규칙 1의 애들의 이동 횟수 값은 등차 수열입니다. 1, 3, 5, 7 ...
# 제곱근과 등차수열 규칙을 잘 스까면 쉽게 풀 수 있는 문제....는 개뿔

# 제곱근을 반올림해줬을 때로 찾고, 그 값의 제곱값이 등차수열이라는것을 알아냈다!
# 입력한 x,y좌표를 토대로 거리값을 구하고 해당 거리값의 제곱근을 반올림해서 구한다.
# 만약 해당 제곱근의 제곱보다 크다면 2 * sqr 하고
# 아니라면 (2 * sqr) - 1 한다.
# 여기서 어떤 값의 제곱이 되는 숫자에서 등차수열 규칙성이 발견되기 때문이다.

import sys
import math

t = int(sys.stdin.readline().split()[0])
arr = []
for _ in range(t) :
    x, y = map(int, sys.stdin.readline().split())
    k = y - x
    sqr = int(round(math.sqrt(k), 0))

    if math.pow(sqr, 2) < k :
        arr.append((2 * sqr))
    else :
        arr.append((2 * sqr) - 1)

for i in arr :
    print(i)